;
; Input signature:
;
; Name                 Index   Mask Register SysValue  Format   Used
; -------------------- ----- ------ -------- -------- ------- ------
; no parameters
;
; Output signature:
;
; Name                 Index   Mask Register SysValue  Format   Used
; -------------------- ----- ------ -------- -------- ------- ------
; no parameters
; shader hash: 0a5d9197692326ced4a466a9379a006a
;
; Pipeline Runtime Information: 
;
;
;
; Buffer Definitions:
;
; cbuffer globalParamsIn
; {
;
;   struct globalParamsIn
;   {
;
;       struct struct.AdvectionDensityCS_GlobalParams
;       {
;
;           uint blockIdxOffset;                      ; Offset:    0
;           uint pad1;                                ; Offset:    4
;           uint pad2;                                ; Offset:    8
;           uint pad3;                                ; Offset:   12
;           struct struct.NvFlowSparseLevelParams
;           {
;
;               uint3 blockDimLessOne;                ; Offset:   16
;               uint threadsPerBlock;                 ; Offset:   28
;               uint3 blockDimBits;                   ; Offset:   32
;               uint numLocations;                    ; Offset:   44
;               uint3 tableDimLessOne;                ; Offset:   48
;               uint tableDim3;                       ; Offset:   60
;               uint tableDimBits_x;                  ; Offset:   64
;               uint tableDimBits_xy;                 ; Offset:   68
;               uint tableDimBits_z;                  ; Offset:   72
;               uint locationOffset;                  ; Offset:   76
;               uint allocationOffset;                ; Offset:   80
;               uint newListOffset;                   ; Offset:   84
;               uint blockLevelOffsetGlobal;          ; Offset:   88
;               uint blockLevelOffsetLocal;           ; Offset:   92
;               uint layerParamIdxOffset;             ; Offset:   96
;               uint numLayers;                       ; Offset:  100
;               uint pad0;                            ; Offset:  104
;               uint pad1;                            ; Offset:  108
;               uint3 dim;                            ; Offset:  112
;               uint maxLocations;                    ; Offset:  124
;               float3 dimInv;                        ; Offset:  128
;               uint numNewLocations;                 ; Offset:  140
;               int4 globalLocationMin;               ; Offset:  144
;               int4 globalLocationMax;               ; Offset:  160
;           
;           } table;                                  ; Offset:   16
;
;           struct struct.NvFlowSparseLevelParams
;           {
;
;               uint3 blockDimLessOne;                ; Offset:  176
;               uint threadsPerBlock;                 ; Offset:  188
;               uint3 blockDimBits;                   ; Offset:  192
;               uint numLocations;                    ; Offset:  204
;               uint3 tableDimLessOne;                ; Offset:  208
;               uint tableDim3;                       ; Offset:  220
;               uint tableDimBits_x;                  ; Offset:  224
;               uint tableDimBits_xy;                 ; Offset:  228
;               uint tableDimBits_z;                  ; Offset:  232
;               uint locationOffset;                  ; Offset:  236
;               uint allocationOffset;                ; Offset:  240
;               uint newListOffset;                   ; Offset:  244
;               uint blockLevelOffsetGlobal;          ; Offset:  248
;               uint blockLevelOffsetLocal;           ; Offset:  252
;               uint layerParamIdxOffset;             ; Offset:  256
;               uint numLayers;                       ; Offset:  260
;               uint pad0;                            ; Offset:  264
;               uint pad1;                            ; Offset:  268
;               uint3 dim;                            ; Offset:  272
;               uint maxLocations;                    ; Offset:  284
;               float3 dimInv;                        ; Offset:  288
;               uint numNewLocations;                 ; Offset:  300
;               int4 globalLocationMin;               ; Offset:  304
;               int4 globalLocationMax;               ; Offset:  320
;           
;           } tableVelocity;                          ; Offset:  176
;
;       
;       } globalParamsIn;                             ; Offset:    0
;
;   
;   } globalParamsIn;                                 ; Offset:    0 Size:   336
;
; }
;
; Resource bind info for layerParamsIn
; {
;
;   struct struct.AdvectionDensityCS_LayerParams
;   {
;
;       struct struct.MacCormackParams
;       {
;
;           struct struct.SemiLagrangianParams
;           {
;
;               float3 valueToVelocityBlockScale;     ; Offset:    0
;               uint globalFetch;                     ; Offset:   12
;               float3 cellSizeInv;                   ; Offset:   16
;               float deltaTime;                      ; Offset:   28
;               float3 maxDisplacement;               ; Offset:   32
;               float pad0;                           ; Offset:   44
;           
;           } base;                                   ; Offset:    0
;
;           float4 blendThreshold;                    ; Offset:   48
;           float4 blendFactor;                       ; Offset:   64
;           float4 dampingRate;                       ; Offset:   80
;           float4 fadeRate;                          ; Offset:   96
;       
;       } advectParams;                               ; Offset:    0
;
;       struct struct.AdvectionCombustionParams
;       {
;
;           float3 gravity;                           ; Offset:  112
;           float burnPerFuel;                        ; Offset:  124
;           float ignitionTemp;                       ; Offset:  128
;           float burnPerTemp;                        ; Offset:  132
;           float fuelPerBurn;                        ; Offset:  136
;           float tempPerBurn;                        ; Offset:  140
;           float smokePerBurn;                       ; Offset:  144
;           float divergencePerBurn;                  ; Offset:  148
;           float buoyancyPerTemp;                    ; Offset:  152
;           float coolingRate;                        ; Offset:  156
;           float buoyancyPerSmoke;                   ; Offset:  160
;           float buoyancyMaxSmoke;                   ; Offset:  164
;           uint combustionEnabled;                   ; Offset:  168
;           float pad3;                               ; Offset:  172
;       
;       } combustParams;                              ; Offset:  112
;
;   
;   } $Element;                                       ; Offset:    0 Size:   176
;
; }
;
; Resource bind info for tableIn
; {
;
;   uint $Element;                                    ; Offset:    0 Size:     4
;
; }
;
;
; Resource Bindings:
;
; Name                                 Type  Format         Dim      ID      HLSL Bind  Count
; ------------------------------ ---------- ------- ----------- ------- -------------- ------
; globalParamsIn                    cbuffer      NA          NA     CB0            cb0     1
; valueSampler                      sampler      NA          NA      S0             s0     1
; layerParamsIn                     texture  struct         r/o      T0             t0     1
; tableIn                           texture  struct         r/o      T1             t1     1
; densityIn                         texture     f32          3d      T2             t2     1
; velocityIn                        texture     f32          3d      T3             t3     1
; densityOut                            UAV     f32          3d      U0             u0     1
;
target datalayout = "e-m:e-p:32:32-i1:32-i8:32-i16:32-i32:32-i64:64-f16:32-f32:32-f64:64-n8:16:32:64"
target triple = "dxil-ms-dx"

%dx.types.Handle = type { i8* }
%dx.types.CBufRet.i32 = type { i32, i32, i32, i32 }
%dx.types.ResRet.i32 = type { i32, i32, i32, i32, i32 }
%dx.types.ResRet.f32 = type { float, float, float, float, i32 }
%dx.types.CBufRet.f32 = type { float, float, float, float }
%"class.StructuredBuffer<AdvectionDensityCS_LayerParams>" = type { %struct.AdvectionDensityCS_LayerParams }
%struct.AdvectionDensityCS_LayerParams = type { %struct.MacCormackParams, %struct.AdvectionCombustionParams }
%struct.MacCormackParams = type { %struct.SemiLagrangianParams, <4 x float>, <4 x float>, <4 x float>, <4 x float> }
%struct.SemiLagrangianParams = type { <3 x float>, i32, <3 x float>, float, <3 x float>, float }
%struct.AdvectionCombustionParams = type { <3 x float>, float, float, float, float, float, float, float, float, float, float, float, i32, float }
%"class.StructuredBuffer<unsigned int>" = type { i32 }
%"class.Texture3D<vector<float, 4> >" = type { <4 x float>, %"class.Texture3D<vector<float, 4> >::mips_type" }
%"class.Texture3D<vector<float, 4> >::mips_type" = type { i32 }
%"class.RWTexture3D<vector<float, 4> >" = type { <4 x float> }
%globalParamsIn = type { %struct.AdvectionDensityCS_GlobalParams }
%struct.AdvectionDensityCS_GlobalParams = type { i32, i32, i32, i32, %struct.NvFlowSparseLevelParams, %struct.NvFlowSparseLevelParams }
%struct.NvFlowSparseLevelParams = type { <3 x i32>, i32, <3 x i32>, i32, <3 x i32>, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, <3 x i32>, i32, <3 x float>, i32, <4 x i32>, <4 x i32> }
%struct.SamplerState = type { i32 }

define void @main() {
  %1 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 1, i32 0, i32 0, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %2 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 0, i32 3, i32 3, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %3 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 0, i32 2, i32 2, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %4 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 0, i32 1, i32 1, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %5 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 0, i32 0, i32 0, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %6 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 3, i32 0, i32 0, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %7 = call %dx.types.Handle @dx.op.createHandle(i32 57, i8 2, i32 0, i32 0, i1 false)  ; CreateHandle(resourceClass,rangeId,index,nonUniformIndex)
  %8 = call i32 @dx.op.threadId.i32(i32 93, i32 0)  ; ThreadId(component)
  %9 = call i32 @dx.op.groupId.i32(i32 94, i32 1)  ; GroupId(component)
  %10 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 1)  ; CBufferLoadLegacy(handle,regIndex)
  %11 = extractvalue %dx.types.CBufRet.i32 %10, 0
  %12 = and i32 %11, %8
  %13 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 2)  ; CBufferLoadLegacy(handle,regIndex)
  %14 = extractvalue %dx.types.CBufRet.i32 %13, 0
  %15 = and i32 %14, 31
  %16 = ashr i32 %8, %15
  %17 = extractvalue %dx.types.CBufRet.i32 %10, 1
  %18 = and i32 %16, %17
  %19 = extractvalue %dx.types.CBufRet.i32 %13, 1
  %20 = add i32 %19, %14
  %21 = and i32 %20, 31
  %22 = ashr i32 %8, %21
  %23 = extractvalue %dx.types.CBufRet.i32 %10, 2
  %24 = and i32 %22, %23
  %25 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 0)  ; CBufferLoadLegacy(handle,regIndex)
  %26 = extractvalue %dx.types.CBufRet.i32 %25, 0
  %27 = add i32 %26, %9
  %28 = extractvalue %dx.types.CBufRet.i32 %13, 3
  %29 = icmp ult i32 %27, %28
  br i1 %29, label %30, label %36

; <label>:30                                      ; preds = %0
  %31 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 6)  ; CBufferLoadLegacy(handle,regIndex)
  %32 = extractvalue %dx.types.CBufRet.i32 %31, 0
  %33 = add i32 %32, %27
  %34 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %33, i32 0)  ; BufferLoad(srv,index,wot)
  %35 = extractvalue %dx.types.ResRet.i32 %34, 0
  br label %36

; <label>:36                                      ; preds = %30, %0
  %37 = phi i32 [ %35, %30 ], [ 0, %0 ]
  %38 = call %dx.types.ResRet.f32 @dx.op.bufferLoad.f32(i32 68, %dx.types.Handle %5, i32 %37, i32 0)  ; BufferLoad(srv,index,wot)
  %39 = extractvalue %dx.types.ResRet.f32 %38, 0
  %40 = extractvalue %dx.types.ResRet.f32 %38, 1
  %41 = extractvalue %dx.types.ResRet.f32 %38, 2
  %42 = sitofp i32 %12 to float
  %43 = sitofp i32 %18 to float
  %44 = sitofp i32 %24 to float
  %45 = fadd fast float %42, 5.000000e-01
  %46 = fadd fast float %43, 5.000000e-01
  %47 = fadd fast float %44, 5.000000e-01
  %48 = fmul fast float %39, %45
  %49 = fmul fast float %40, %46
  %50 = fmul fast float %41, %47
  %51 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %5, i32 %37, i32 12)  ; BufferLoad(srv,index,wot)
  %52 = extractvalue %dx.types.ResRet.i32 %51, 0
  %53 = icmp eq i32 %52, 0
  %54 = call float @dx.op.unary.f32(i32 27, float %48)  ; Round_ni(value)
  %55 = call float @dx.op.unary.f32(i32 27, float %49)  ; Round_ni(value)
  %56 = call float @dx.op.unary.f32(i32 27, float %50)  ; Round_ni(value)
  %57 = fptosi float %54 to i32
  %58 = fptosi float %55 to i32
  %59 = fptosi float %56 to i32
  %60 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 12)  ; CBufferLoadLegacy(handle,regIndex)
  br i1 %53, label %211, label %61

; <label>:61                                      ; preds = %36
  %62 = extractvalue %dx.types.CBufRet.i32 %60, 3
  %63 = icmp ult i32 %27, %62
  br i1 %63, label %64, label %80

; <label>:64                                      ; preds = %61
  %65 = shl i32 %27, 2
  %66 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 14)  ; CBufferLoadLegacy(handle,regIndex)
  %67 = extractvalue %dx.types.CBufRet.i32 %66, 3
  %68 = add i32 %67, %65
  %69 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %68, i32 0)  ; BufferLoad(srv,index,wot)
  %70 = extractvalue %dx.types.ResRet.i32 %69, 0
  %71 = add i32 %68, 1
  %72 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %71, i32 0)  ; BufferLoad(srv,index,wot)
  %73 = extractvalue %dx.types.ResRet.i32 %72, 0
  %74 = add i32 %68, 2
  %75 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %74, i32 0)  ; BufferLoad(srv,index,wot)
  %76 = extractvalue %dx.types.ResRet.i32 %75, 0
  %77 = add i32 %68, 3
  %78 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %77, i32 0)  ; BufferLoad(srv,index,wot)
  %79 = extractvalue %dx.types.ResRet.i32 %78, 0
  br label %80

; <label>:80                                      ; preds = %64, %61
  %81 = phi i32 [ %70, %64 ], [ 1073741824, %61 ]
  %82 = phi i32 [ %73, %64 ], [ 1073741824, %61 ]
  %83 = phi i32 [ %76, %64 ], [ 1073741824, %61 ]
  %84 = phi i32 [ %79, %64 ], [ 1073741824, %61 ]
  %85 = extractvalue %dx.types.CBufRet.i32 %60, 0
  %86 = extractvalue %dx.types.CBufRet.i32 %60, 1
  %87 = extractvalue %dx.types.CBufRet.i32 %60, 2
  %88 = and i32 %85, 31
  %89 = and i32 %86, 31
  %90 = and i32 %87, 31
  %91 = shl i32 %81, %88
  %92 = shl i32 %82, %89
  %93 = shl i32 %83, %90
  %94 = add i32 %91, %57
  %95 = add i32 %92, %58
  %96 = add i32 %93, %59
  %97 = ashr i32 %94, %88
  %98 = ashr i32 %95, %89
  %99 = ashr i32 %96, %90
  %100 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 13)  ; CBufferLoadLegacy(handle,regIndex)
  %101 = extractvalue %dx.types.CBufRet.i32 %100, 0
  %102 = extractvalue %dx.types.CBufRet.i32 %100, 1
  %103 = extractvalue %dx.types.CBufRet.i32 %100, 2
  %104 = and i32 %97, %101
  %105 = and i32 %98, %102
  %106 = and i32 %99, %103
  %107 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 14)  ; CBufferLoadLegacy(handle,regIndex)
  %108 = extractvalue %dx.types.CBufRet.i32 %107, 1
  %109 = and i32 %108, 31
  %110 = shl i32 %106, %109
  %111 = extractvalue %dx.types.CBufRet.i32 %107, 0
  %112 = and i32 %111, 31
  %113 = shl i32 %105, %112
  %114 = or i32 %113, %104
  %115 = or i32 %114, %110
  %116 = shl i32 %115, 1
  %117 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %116, i32 0)  ; BufferLoad(srv,index,wot)
  %118 = extractvalue %dx.types.ResRet.i32 %117, 0
  %119 = or i32 %116, 1
  %120 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %119, i32 0)  ; BufferLoad(srv,index,wot)
  %121 = extractvalue %dx.types.ResRet.i32 %120, 0
  %122 = icmp ult i32 %118, %121
  br i1 %122, label %123, label %153

; <label>:123                                     ; preds = %80
  br label %124

; <label>:124                                     ; preds = %148, %123
  %125 = phi i32 [ %149, %148 ], [ %118, %123 ]
  %126 = shl i32 %125, 2
  %127 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 14)  ; CBufferLoadLegacy(handle,regIndex)
  %128 = extractvalue %dx.types.CBufRet.i32 %127, 3
  %129 = add i32 %128, %126
  %130 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %129, i32 0)  ; BufferLoad(srv,index,wot)
  %131 = extractvalue %dx.types.ResRet.i32 %130, 0
  %132 = add i32 %129, 1
  %133 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %132, i32 0)  ; BufferLoad(srv,index,wot)
  %134 = extractvalue %dx.types.ResRet.i32 %133, 0
  %135 = add i32 %129, 2
  %136 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %135, i32 0)  ; BufferLoad(srv,index,wot)
  %137 = extractvalue %dx.types.ResRet.i32 %136, 0
  %138 = add i32 %129, 3
  %139 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %138, i32 0)  ; BufferLoad(srv,index,wot)
  %140 = extractvalue %dx.types.ResRet.i32 %139, 0
  %141 = icmp eq i32 %131, %97
  %142 = icmp eq i32 %134, %98
  %143 = and i1 %141, %142
  %144 = icmp eq i32 %137, %99
  %145 = and i1 %143, %144
  %146 = icmp eq i32 %140, %84
  %147 = and i1 %145, %146
  br i1 %147, label %151, label %148

; <label>:148                                     ; preds = %124
  %149 = add nuw i32 %125, 1
  %150 = icmp ult i32 %149, %121
  br i1 %150, label %124, label %151

; <label>:151                                     ; preds = %148, %124
  %152 = phi i32 [ -1, %148 ], [ %125, %124 ]
  br label %153

; <label>:153                                     ; preds = %151, %80
  %154 = phi i32 [ -1, %80 ], [ %152, %151 ]
  %155 = icmp ne i32 %154, -1
  %156 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 15)  ; CBufferLoadLegacy(handle,regIndex)
  %157 = extractvalue %dx.types.CBufRet.i32 %156, 2
  %158 = add i32 %157, %154
  %159 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %158, i32 0)  ; BufferLoad(srv,index,wot)
  %160 = extractvalue %dx.types.ResRet.i32 %159, 0
  %161 = select i1 %155, i32 %160, i32 0
  %162 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 11)  ; CBufferLoadLegacy(handle,regIndex)
  %163 = extractvalue %dx.types.CBufRet.i32 %162, 0
  %164 = extractvalue %dx.types.CBufRet.i32 %162, 1
  %165 = extractvalue %dx.types.CBufRet.i32 %162, 2
  %166 = and i32 %163, %94
  %167 = and i32 %164, %95
  %168 = and i32 %165, %96
  %169 = shl i32 %161, 1
  %170 = or i32 %169, 1
  %171 = add nsw i32 %170, %166
  %172 = and i32 %171, 4095
  %173 = lshr i32 %161, 10
  %174 = or i32 %173, 1
  %175 = add nsw i32 %174, %167
  %176 = and i32 %175, 2047
  %177 = lshr i32 %161, 20
  %178 = or i32 %177, 1
  %179 = add nsw i32 %178, %168
  %180 = and i32 %179, 2047
  %181 = and i32 %161, -2147483648
  %182 = or i32 %172, %181
  %183 = xor i32 %182, -2147483648
  %184 = sitofp i32 %183 to float
  %185 = sitofp i32 %176 to float
  %186 = sitofp i32 %180 to float
  %187 = sitofp i32 %57 to float
  %188 = sitofp i32 %58 to float
  %189 = sitofp i32 %59 to float
  %190 = fsub fast float %48, %187
  %191 = fadd fast float %190, %184
  %192 = fsub fast float %49, %188
  %193 = fadd fast float %192, %185
  %194 = fsub fast float %50, %189
  %195 = fadd fast float %194, %186
  %196 = icmp slt i32 %161, 0
  %197 = call %dx.types.CBufRet.f32 @dx.op.cbufferLoadLegacy.f32(i32 59, %dx.types.Handle %7, i32 18)  ; CBufferLoadLegacy(handle,regIndex)
  %198 = extractvalue %dx.types.CBufRet.f32 %197, 0
  %199 = extractvalue %dx.types.CBufRet.f32 %197, 1
  %200 = extractvalue %dx.types.CBufRet.f32 %197, 2
  %201 = fmul fast float %191, %198
  %202 = fmul fast float %193, %199
  %203 = fmul fast float %195, %200
  %204 = call %dx.types.ResRet.f32 @dx.op.sampleLevel.f32(i32 62, %dx.types.Handle %2, %dx.types.Handle %6, float %201, float %202, float %203, float undef, i32 0, i32 0, i32 0, float 0.000000e+00)  ; SampleLevel(srv,sampler,coord0,coord1,coord2,coord3,offset0,offset1,offset2,LOD)
  %205 = extractvalue %dx.types.ResRet.f32 %204, 0
  %206 = extractvalue %dx.types.ResRet.f32 %204, 1
  %207 = extractvalue %dx.types.ResRet.f32 %204, 2
  %208 = select i1 %196, float %205, float 0.000000e+00
  %209 = select i1 %196, float %206, float 0.000000e+00
  %210 = select i1 %196, float %207, float 0.000000e+00
  br label %276

; <label>:211                                     ; preds = %36
  %212 = extractvalue %dx.types.CBufRet.i32 %60, 0
  %213 = extractvalue %dx.types.CBufRet.i32 %60, 1
  %214 = extractvalue %dx.types.CBufRet.i32 %60, 2
  %215 = and i32 %212, 31
  %216 = and i32 %213, 31
  %217 = and i32 %214, 31
  %218 = ashr i32 %57, %215
  %219 = ashr i32 %58, %216
  %220 = ashr i32 %59, %217
  %221 = shl i32 %27, 5
  %222 = mul i32 %220, 9
  %223 = mul i32 %219, 3
  %224 = add i32 %218, 18
  %225 = add i32 %224, %223
  %226 = add i32 %225, %222
  %227 = and i32 %226, 31
  %228 = or i32 %227, %221
  %229 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 15)  ; CBufferLoadLegacy(handle,regIndex)
  %230 = extractvalue %dx.types.CBufRet.i32 %229, 3
  %231 = add i32 %228, %230
  %232 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %231, i32 0)  ; BufferLoad(srv,index,wot)
  %233 = extractvalue %dx.types.ResRet.i32 %232, 0
  %234 = shl i32 %233, 1
  %235 = or i32 %234, 1
  %236 = add nsw i32 %235, %57
  %237 = and i32 %236, 4095
  %238 = lshr i32 %233, 10
  %239 = or i32 %238, 1
  %240 = add nsw i32 %239, %58
  %241 = and i32 %240, 2047
  %242 = lshr i32 %233, 20
  %243 = or i32 %242, 1
  %244 = add nsw i32 %243, %59
  %245 = and i32 %244, 2047
  %246 = and i32 %233, -2147483648
  %247 = or i32 %237, %246
  %248 = xor i32 %247, -2147483648
  %249 = sitofp i32 %248 to float
  %250 = sitofp i32 %241 to float
  %251 = sitofp i32 %245 to float
  %252 = sitofp i32 %57 to float
  %253 = sitofp i32 %58 to float
  %254 = sitofp i32 %59 to float
  %255 = fsub fast float %48, %252
  %256 = fadd fast float %255, %249
  %257 = fsub fast float %49, %253
  %258 = fadd fast float %257, %250
  %259 = fsub fast float %50, %254
  %260 = fadd fast float %259, %251
  %261 = icmp slt i32 %233, 0
  %262 = call %dx.types.CBufRet.f32 @dx.op.cbufferLoadLegacy.f32(i32 59, %dx.types.Handle %7, i32 18)  ; CBufferLoadLegacy(handle,regIndex)
  %263 = extractvalue %dx.types.CBufRet.f32 %262, 0
  %264 = extractvalue %dx.types.CBufRet.f32 %262, 1
  %265 = extractvalue %dx.types.CBufRet.f32 %262, 2
  %266 = fmul fast float %256, %263
  %267 = fmul fast float %258, %264
  %268 = fmul fast float %260, %265
  %269 = call %dx.types.ResRet.f32 @dx.op.sampleLevel.f32(i32 62, %dx.types.Handle %2, %dx.types.Handle %6, float %266, float %267, float %268, float undef, i32 0, i32 0, i32 0, float 0.000000e+00)  ; SampleLevel(srv,sampler,coord0,coord1,coord2,coord3,offset0,offset1,offset2,LOD)
  %270 = extractvalue %dx.types.ResRet.f32 %269, 0
  %271 = extractvalue %dx.types.ResRet.f32 %269, 1
  %272 = extractvalue %dx.types.ResRet.f32 %269, 2
  %273 = select i1 %261, float %270, float 0.000000e+00
  %274 = select i1 %261, float %271, float 0.000000e+00
  %275 = select i1 %261, float %272, float 0.000000e+00
  br label %276

; <label>:276                                     ; preds = %211, %153
  %277 = phi float [ %208, %153 ], [ %273, %211 ]
  %278 = phi float [ %209, %153 ], [ %274, %211 ]
  %279 = phi float [ %210, %153 ], [ %275, %211 ]
  %280 = call %dx.types.ResRet.f32 @dx.op.bufferLoad.f32(i32 68, %dx.types.Handle %5, i32 %37, i32 28)  ; BufferLoad(srv,index,wot)
  %281 = extractvalue %dx.types.ResRet.f32 %280, 0
  %282 = call %dx.types.ResRet.f32 @dx.op.bufferLoad.f32(i32 68, %dx.types.Handle %5, i32 %37, i32 16)  ; BufferLoad(srv,index,wot)
  %283 = extractvalue %dx.types.ResRet.f32 %282, 0
  %284 = extractvalue %dx.types.ResRet.f32 %282, 1
  %285 = extractvalue %dx.types.ResRet.f32 %282, 2
  %286 = fmul fast float %281, %277
  %287 = fmul fast float %286, %283
  %288 = fmul fast float %281, %278
  %289 = fmul fast float %288, %284
  %290 = fmul fast float %281, %279
  %291 = fmul fast float %290, %285
  br i1 %53, label %292, label %306

; <label>:292                                     ; preds = %276
  %293 = call %dx.types.ResRet.f32 @dx.op.bufferLoad.f32(i32 68, %dx.types.Handle %5, i32 %37, i32 32)  ; BufferLoad(srv,index,wot)
  %294 = extractvalue %dx.types.ResRet.f32 %293, 0
  %295 = extractvalue %dx.types.ResRet.f32 %293, 1
  %296 = extractvalue %dx.types.ResRet.f32 %293, 2
  %297 = fsub fast float -0.000000e+00, %294
  %298 = fsub fast float -0.000000e+00, %295
  %299 = fsub fast float -0.000000e+00, %296
  %300 = call float @dx.op.binary.f32(i32 35, float %287, float %297)  ; FMax(a,b)
  %301 = call float @dx.op.binary.f32(i32 35, float %289, float %298)  ; FMax(a,b)
  %302 = call float @dx.op.binary.f32(i32 35, float %291, float %299)  ; FMax(a,b)
  %303 = call float @dx.op.binary.f32(i32 36, float %300, float %294)  ; FMin(a,b)
  %304 = call float @dx.op.binary.f32(i32 36, float %301, float %295)  ; FMin(a,b)
  %305 = call float @dx.op.binary.f32(i32 36, float %302, float %296)  ; FMin(a,b)
  br label %306

; <label>:306                                     ; preds = %292, %276
  %307 = phi float [ %303, %292 ], [ %287, %276 ]
  %308 = phi float [ %304, %292 ], [ %289, %276 ]
  %309 = phi float [ %305, %292 ], [ %291, %276 ]
  %310 = fsub fast float %45, %307
  %311 = fsub fast float %46, %308
  %312 = fsub fast float %47, %309
  %313 = call float @dx.op.unary.f32(i32 27, float %310)  ; Round_ni(value)
  %314 = call float @dx.op.unary.f32(i32 27, float %311)  ; Round_ni(value)
  %315 = call float @dx.op.unary.f32(i32 27, float %312)  ; Round_ni(value)
  %316 = fptosi float %313 to i32
  %317 = fptosi float %314 to i32
  %318 = fptosi float %315 to i32
  br i1 %53, label %463, label %319

; <label>:319                                     ; preds = %306
  br i1 %29, label %320, label %336

; <label>:320                                     ; preds = %319
  %321 = shl i32 %27, 2
  %322 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 4)  ; CBufferLoadLegacy(handle,regIndex)
  %323 = extractvalue %dx.types.CBufRet.i32 %322, 3
  %324 = add i32 %323, %321
  %325 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %324, i32 0)  ; BufferLoad(srv,index,wot)
  %326 = extractvalue %dx.types.ResRet.i32 %325, 0
  %327 = add i32 %324, 1
  %328 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %327, i32 0)  ; BufferLoad(srv,index,wot)
  %329 = extractvalue %dx.types.ResRet.i32 %328, 0
  %330 = add i32 %324, 2
  %331 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %330, i32 0)  ; BufferLoad(srv,index,wot)
  %332 = extractvalue %dx.types.ResRet.i32 %331, 0
  %333 = add i32 %324, 3
  %334 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %333, i32 0)  ; BufferLoad(srv,index,wot)
  %335 = extractvalue %dx.types.ResRet.i32 %334, 0
  br label %336

; <label>:336                                     ; preds = %320, %319
  %337 = phi i32 [ %326, %320 ], [ 1073741824, %319 ]
  %338 = phi i32 [ %329, %320 ], [ 1073741824, %319 ]
  %339 = phi i32 [ %332, %320 ], [ 1073741824, %319 ]
  %340 = phi i32 [ %335, %320 ], [ 1073741824, %319 ]
  %341 = extractvalue %dx.types.CBufRet.i32 %13, 2
  %342 = and i32 %19, 31
  %343 = and i32 %341, 31
  %344 = shl i32 %337, %15
  %345 = shl i32 %338, %342
  %346 = shl i32 %339, %343
  %347 = add i32 %344, %316
  %348 = add i32 %345, %317
  %349 = add i32 %346, %318
  %350 = ashr i32 %347, %15
  %351 = ashr i32 %348, %342
  %352 = ashr i32 %349, %343
  %353 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 3)  ; CBufferLoadLegacy(handle,regIndex)
  %354 = extractvalue %dx.types.CBufRet.i32 %353, 0
  %355 = extractvalue %dx.types.CBufRet.i32 %353, 1
  %356 = extractvalue %dx.types.CBufRet.i32 %353, 2
  %357 = and i32 %350, %354
  %358 = and i32 %351, %355
  %359 = and i32 %352, %356
  %360 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 4)  ; CBufferLoadLegacy(handle,regIndex)
  %361 = extractvalue %dx.types.CBufRet.i32 %360, 1
  %362 = and i32 %361, 31
  %363 = shl i32 %359, %362
  %364 = extractvalue %dx.types.CBufRet.i32 %360, 0
  %365 = and i32 %364, 31
  %366 = shl i32 %358, %365
  %367 = or i32 %366, %357
  %368 = or i32 %367, %363
  %369 = shl i32 %368, 1
  %370 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %369, i32 0)  ; BufferLoad(srv,index,wot)
  %371 = extractvalue %dx.types.ResRet.i32 %370, 0
  %372 = or i32 %369, 1
  %373 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %372, i32 0)  ; BufferLoad(srv,index,wot)
  %374 = extractvalue %dx.types.ResRet.i32 %373, 0
  %375 = icmp ult i32 %371, %374
  br i1 %375, label %376, label %406

; <label>:376                                     ; preds = %336
  br label %377

; <label>:377                                     ; preds = %401, %376
  %378 = phi i32 [ %402, %401 ], [ %371, %376 ]
  %379 = shl i32 %378, 2
  %380 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 4)  ; CBufferLoadLegacy(handle,regIndex)
  %381 = extractvalue %dx.types.CBufRet.i32 %380, 3
  %382 = add i32 %381, %379
  %383 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %382, i32 0)  ; BufferLoad(srv,index,wot)
  %384 = extractvalue %dx.types.ResRet.i32 %383, 0
  %385 = add i32 %382, 1
  %386 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %385, i32 0)  ; BufferLoad(srv,index,wot)
  %387 = extractvalue %dx.types.ResRet.i32 %386, 0
  %388 = add i32 %382, 2
  %389 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %388, i32 0)  ; BufferLoad(srv,index,wot)
  %390 = extractvalue %dx.types.ResRet.i32 %389, 0
  %391 = add i32 %382, 3
  %392 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %391, i32 0)  ; BufferLoad(srv,index,wot)
  %393 = extractvalue %dx.types.ResRet.i32 %392, 0
  %394 = icmp eq i32 %384, %350
  %395 = icmp eq i32 %387, %351
  %396 = and i1 %394, %395
  %397 = icmp eq i32 %390, %352
  %398 = and i1 %396, %397
  %399 = icmp eq i32 %393, %340
  %400 = and i1 %398, %399
  br i1 %400, label %404, label %401

; <label>:401                                     ; preds = %377
  %402 = add nuw i32 %378, 1
  %403 = icmp ult i32 %402, %374
  br i1 %403, label %377, label %404

; <label>:404                                     ; preds = %401, %377
  %405 = phi i32 [ -1, %401 ], [ %378, %377 ]
  br label %406

; <label>:406                                     ; preds = %404, %336
  %407 = phi i32 [ -1, %336 ], [ %405, %404 ]
  %408 = icmp ne i32 %407, -1
  %409 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %410 = extractvalue %dx.types.CBufRet.i32 %409, 2
  %411 = add i32 %410, %407
  %412 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %411, i32 0)  ; BufferLoad(srv,index,wot)
  %413 = extractvalue %dx.types.ResRet.i32 %412, 0
  %414 = select i1 %408, i32 %413, i32 0
  %415 = and i32 %11, %347
  %416 = and i32 %17, %348
  %417 = and i32 %23, %349
  %418 = shl i32 %414, 1
  %419 = or i32 %418, 1
  %420 = add nsw i32 %419, %415
  %421 = and i32 %420, 4095
  %422 = lshr i32 %414, 10
  %423 = or i32 %422, 1
  %424 = add nsw i32 %423, %416
  %425 = and i32 %424, 2047
  %426 = lshr i32 %414, 20
  %427 = or i32 %426, 1
  %428 = add nsw i32 %427, %417
  %429 = and i32 %428, 2047
  %430 = and i32 %414, -2147483648
  %431 = or i32 %421, %430
  %432 = xor i32 %431, -2147483648
  %433 = sitofp i32 %432 to float
  %434 = sitofp i32 %425 to float
  %435 = sitofp i32 %429 to float
  %436 = sitofp i32 %316 to float
  %437 = sitofp i32 %317 to float
  %438 = sitofp i32 %318 to float
  %439 = fsub fast float %310, %436
  %440 = fadd fast float %439, %433
  %441 = fsub fast float %311, %437
  %442 = fadd fast float %441, %434
  %443 = fsub fast float %312, %438
  %444 = fadd fast float %443, %435
  %445 = icmp slt i32 %414, 0
  %446 = call %dx.types.CBufRet.f32 @dx.op.cbufferLoadLegacy.f32(i32 59, %dx.types.Handle %7, i32 8)  ; CBufferLoadLegacy(handle,regIndex)
  %447 = extractvalue %dx.types.CBufRet.f32 %446, 0
  %448 = extractvalue %dx.types.CBufRet.f32 %446, 1
  %449 = extractvalue %dx.types.CBufRet.f32 %446, 2
  %450 = fmul fast float %440, %447
  %451 = fmul fast float %442, %448
  %452 = fmul fast float %444, %449
  %453 = call %dx.types.ResRet.f32 @dx.op.sampleLevel.f32(i32 62, %dx.types.Handle %3, %dx.types.Handle %6, float %450, float %451, float %452, float undef, i32 0, i32 0, i32 0, float 0.000000e+00)  ; SampleLevel(srv,sampler,coord0,coord1,coord2,coord3,offset0,offset1,offset2,LOD)
  %454 = extractvalue %dx.types.ResRet.f32 %453, 0
  %455 = extractvalue %dx.types.ResRet.f32 %453, 1
  %456 = extractvalue %dx.types.ResRet.f32 %453, 2
  %457 = extractvalue %dx.types.ResRet.f32 %453, 3
  %458 = select i1 %445, float %454, float 0.000000e+00
  %459 = select i1 %445, float %455, float 0.000000e+00
  %460 = select i1 %445, float %456, float 0.000000e+00
  %461 = select i1 %445, float %457, float 0.000000e+00
  %462 = shl i32 %27, 5
  br label %527

; <label>:463                                     ; preds = %306
  %464 = extractvalue %dx.types.CBufRet.i32 %13, 2
  %465 = and i32 %19, 31
  %466 = and i32 %464, 31
  %467 = ashr i32 %316, %15
  %468 = ashr i32 %317, %465
  %469 = ashr i32 %318, %466
  %470 = shl i32 %27, 5
  %471 = mul i32 %469, 9
  %472 = mul i32 %468, 3
  %473 = add i32 %467, 18
  %474 = add i32 %473, %472
  %475 = add i32 %474, %471
  %476 = and i32 %475, 31
  %477 = or i32 %476, %470
  %478 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %479 = extractvalue %dx.types.CBufRet.i32 %478, 3
  %480 = add i32 %477, %479
  %481 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %480, i32 0)  ; BufferLoad(srv,index,wot)
  %482 = extractvalue %dx.types.ResRet.i32 %481, 0
  %483 = shl i32 %482, 1
  %484 = or i32 %483, 1
  %485 = add nsw i32 %484, %316
  %486 = and i32 %485, 4095
  %487 = lshr i32 %482, 10
  %488 = or i32 %487, 1
  %489 = add nsw i32 %488, %317
  %490 = and i32 %489, 2047
  %491 = lshr i32 %482, 20
  %492 = or i32 %491, 1
  %493 = add nsw i32 %492, %318
  %494 = and i32 %493, 2047
  %495 = and i32 %482, -2147483648
  %496 = or i32 %486, %495
  %497 = xor i32 %496, -2147483648
  %498 = sitofp i32 %497 to float
  %499 = sitofp i32 %490 to float
  %500 = sitofp i32 %494 to float
  %501 = sitofp i32 %316 to float
  %502 = sitofp i32 %317 to float
  %503 = sitofp i32 %318 to float
  %504 = fsub fast float %310, %501
  %505 = fadd fast float %504, %498
  %506 = fsub fast float %311, %502
  %507 = fadd fast float %506, %499
  %508 = fsub fast float %312, %503
  %509 = fadd fast float %508, %500
  %510 = icmp slt i32 %482, 0
  %511 = call %dx.types.CBufRet.f32 @dx.op.cbufferLoadLegacy.f32(i32 59, %dx.types.Handle %7, i32 8)  ; CBufferLoadLegacy(handle,regIndex)
  %512 = extractvalue %dx.types.CBufRet.f32 %511, 0
  %513 = extractvalue %dx.types.CBufRet.f32 %511, 1
  %514 = extractvalue %dx.types.CBufRet.f32 %511, 2
  %515 = fmul fast float %505, %512
  %516 = fmul fast float %507, %513
  %517 = fmul fast float %509, %514
  %518 = call %dx.types.ResRet.f32 @dx.op.sampleLevel.f32(i32 62, %dx.types.Handle %3, %dx.types.Handle %6, float %515, float %516, float %517, float undef, i32 0, i32 0, i32 0, float 0.000000e+00)  ; SampleLevel(srv,sampler,coord0,coord1,coord2,coord3,offset0,offset1,offset2,LOD)
  %519 = extractvalue %dx.types.ResRet.f32 %518, 0
  %520 = extractvalue %dx.types.ResRet.f32 %518, 1
  %521 = extractvalue %dx.types.ResRet.f32 %518, 2
  %522 = extractvalue %dx.types.ResRet.f32 %518, 3
  %523 = select i1 %510, float %519, float 0.000000e+00
  %524 = select i1 %510, float %520, float 0.000000e+00
  %525 = select i1 %510, float %521, float 0.000000e+00
  %526 = select i1 %510, float %522, float 0.000000e+00
  br label %527

; <label>:527                                     ; preds = %463, %406
  %528 = phi i32 [ %462, %406 ], [ %470, %463 ]
  %529 = phi float [ %458, %406 ], [ %523, %463 ]
  %530 = phi float [ %459, %406 ], [ %524, %463 ]
  %531 = phi float [ %460, %406 ], [ %525, %463 ]
  %532 = phi float [ %461, %406 ], [ %526, %463 ]
  %533 = icmp eq i32 %12, 0
  %534 = sext i1 %533 to i32
  %535 = icmp eq i32 %12, %11
  %536 = select i1 %535, i32 1, i32 %534
  %537 = icmp eq i32 %18, 0
  %538 = sext i1 %537 to i32
  %539 = icmp eq i32 %18, %17
  %540 = select i1 %539, i32 1, i32 %538
  %541 = icmp eq i32 %24, 0
  %542 = sext i1 %541 to i32
  %543 = icmp eq i32 %24, %23
  %544 = select i1 %543, i32 1, i32 %542
  %545 = or i32 %528, 18
  %546 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %547 = extractvalue %dx.types.CBufRet.i32 %546, 3
  %548 = add i32 %547, %545
  %549 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %548, i32 0)  ; BufferLoad(srv,index,wot)
  %550 = extractvalue %dx.types.ResRet.i32 %549, 0
  %551 = shl i32 %550, 1
  %552 = or i32 %551, 1
  %553 = add nsw i32 %552, %12
  %554 = and i32 %553, 4095
  %555 = lshr i32 %550, 10
  %556 = or i32 %555, 1
  %557 = add nsw i32 %556, %18
  %558 = and i32 %557, 2047
  %559 = lshr i32 %550, 20
  %560 = or i32 %559, 1
  %561 = add nsw i32 %560, %24
  %562 = and i32 %561, 2047
  %563 = icmp slt i32 %550, 0
  %564 = select i1 %563, float %529, float 0.000000e+00
  %565 = select i1 %563, float %530, float 0.000000e+00
  %566 = select i1 %563, float %531, float 0.000000e+00
  %567 = select i1 %563, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %554, i32 %558, i32 %562, float %564, float %565, float %566, float %567, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  %568 = icmp eq i32 %536, 0
  br i1 %568, label %599, label %569

; <label>:569                                     ; preds = %527
  %570 = add nsw i32 %536, 18
  %571 = and i32 %570, 31
  %572 = or i32 %571, %528
  %573 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %574 = extractvalue %dx.types.CBufRet.i32 %573, 3
  %575 = add i32 %574, %572
  %576 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %575, i32 0)  ; BufferLoad(srv,index,wot)
  %577 = extractvalue %dx.types.ResRet.i32 %576, 0
  %578 = shl i32 %577, 1
  %579 = or i32 %578, 1
  %580 = add nsw i32 %579, %12
  %581 = and i32 %580, 4095
  %582 = lshr i32 %577, 10
  %583 = or i32 %582, 1
  %584 = add nsw i32 %583, %18
  %585 = and i32 %584, 2047
  %586 = lshr i32 %577, 20
  %587 = or i32 %586, 1
  %588 = add nsw i32 %587, %24
  %589 = and i32 %588, 2047
  %590 = xor i32 %577, -2147483648
  %591 = ashr i32 %590, 31
  %592 = and i32 %591, %536
  %593 = add nsw i32 %581, %592
  %594 = icmp slt i32 %577, 0
  %595 = select i1 %594, float %529, float 0.000000e+00
  %596 = select i1 %594, float %530, float 0.000000e+00
  %597 = select i1 %594, float %531, float 0.000000e+00
  %598 = select i1 %594, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %593, i32 %585, i32 %589, float %595, float %596, float %597, float %598, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %599

; <label>:599                                     ; preds = %569, %527
  %600 = icmp eq i32 %540, 0
  br i1 %600, label %632, label %601

; <label>:601                                     ; preds = %599
  %602 = mul nsw i32 %540, 3
  %603 = add nsw i32 %602, 18
  %604 = and i32 %603, 31
  %605 = or i32 %604, %528
  %606 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %607 = extractvalue %dx.types.CBufRet.i32 %606, 3
  %608 = add i32 %607, %605
  %609 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %608, i32 0)  ; BufferLoad(srv,index,wot)
  %610 = extractvalue %dx.types.ResRet.i32 %609, 0
  %611 = shl i32 %610, 1
  %612 = or i32 %611, 1
  %613 = add nsw i32 %612, %12
  %614 = and i32 %613, 4095
  %615 = lshr i32 %610, 10
  %616 = or i32 %615, 1
  %617 = add nsw i32 %616, %18
  %618 = and i32 %617, 2047
  %619 = lshr i32 %610, 20
  %620 = or i32 %619, 1
  %621 = add nsw i32 %620, %24
  %622 = and i32 %621, 2047
  %623 = xor i32 %610, -2147483648
  %624 = ashr i32 %623, 31
  %625 = and i32 %624, %540
  %626 = add nsw i32 %618, %625
  %627 = icmp slt i32 %610, 0
  %628 = select i1 %627, float %529, float 0.000000e+00
  %629 = select i1 %627, float %530, float 0.000000e+00
  %630 = select i1 %627, float %531, float 0.000000e+00
  %631 = select i1 %627, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %614, i32 %626, i32 %622, float %628, float %629, float %630, float %631, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %632

; <label>:632                                     ; preds = %601, %599
  %633 = icmp eq i32 %544, 0
  br i1 %633, label %665, label %634

; <label>:634                                     ; preds = %632
  %635 = mul nsw i32 %544, 9
  %636 = add nsw i32 %635, 18
  %637 = and i32 %636, 31
  %638 = or i32 %637, %528
  %639 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %640 = extractvalue %dx.types.CBufRet.i32 %639, 3
  %641 = add i32 %640, %638
  %642 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %641, i32 0)  ; BufferLoad(srv,index,wot)
  %643 = extractvalue %dx.types.ResRet.i32 %642, 0
  %644 = shl i32 %643, 1
  %645 = or i32 %644, 1
  %646 = add nsw i32 %645, %12
  %647 = and i32 %646, 4095
  %648 = lshr i32 %643, 10
  %649 = or i32 %648, 1
  %650 = add nsw i32 %649, %18
  %651 = and i32 %650, 2047
  %652 = lshr i32 %643, 20
  %653 = or i32 %652, 1
  %654 = add nsw i32 %653, %24
  %655 = and i32 %654, 2047
  %656 = xor i32 %643, -2147483648
  %657 = ashr i32 %656, 31
  %658 = and i32 %657, %544
  %659 = add nsw i32 %655, %658
  %660 = icmp slt i32 %643, 0
  %661 = select i1 %660, float %529, float 0.000000e+00
  %662 = select i1 %660, float %530, float 0.000000e+00
  %663 = select i1 %660, float %531, float 0.000000e+00
  %664 = select i1 %660, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %647, i32 %651, i32 %659, float %661, float %662, float %663, float %664, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %665

; <label>:665                                     ; preds = %634, %632
  %666 = icmp ne i32 %536, 0
  %667 = icmp ne i32 %540, 0
  %668 = and i1 %666, %667
  br i1 %668, label %669, label %703

; <label>:669                                     ; preds = %665
  %670 = mul nsw i32 %540, 3
  %671 = add nsw i32 %536, 18
  %672 = add i32 %671, %670
  %673 = and i32 %672, 31
  %674 = or i32 %673, %528
  %675 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %676 = extractvalue %dx.types.CBufRet.i32 %675, 3
  %677 = add i32 %676, %674
  %678 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %677, i32 0)  ; BufferLoad(srv,index,wot)
  %679 = extractvalue %dx.types.ResRet.i32 %678, 0
  %680 = shl i32 %679, 1
  %681 = or i32 %680, 1
  %682 = add nsw i32 %681, %12
  %683 = and i32 %682, 4095
  %684 = lshr i32 %679, 10
  %685 = or i32 %684, 1
  %686 = add nsw i32 %685, %18
  %687 = and i32 %686, 2047
  %688 = lshr i32 %679, 20
  %689 = or i32 %688, 1
  %690 = add nsw i32 %689, %24
  %691 = and i32 %690, 2047
  %692 = xor i32 %679, -2147483648
  %693 = ashr i32 %692, 31
  %694 = and i32 %693, %536
  %695 = add nsw i32 %683, %694
  %696 = and i32 %693, %540
  %697 = add nsw i32 %687, %696
  %698 = icmp slt i32 %679, 0
  %699 = select i1 %698, float %529, float 0.000000e+00
  %700 = select i1 %698, float %530, float 0.000000e+00
  %701 = select i1 %698, float %531, float 0.000000e+00
  %702 = select i1 %698, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %695, i32 %697, i32 %691, float %699, float %700, float %701, float %702, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %703

; <label>:703                                     ; preds = %669, %665
  %704 = icmp ne i32 %544, 0
  %705 = and i1 %667, %704
  br i1 %705, label %706, label %741

; <label>:706                                     ; preds = %703
  %707 = mul nsw i32 %544, 9
  %708 = mul nsw i32 %540, 3
  %709 = add i32 %708, 18
  %710 = add i32 %709, %707
  %711 = and i32 %710, 31
  %712 = or i32 %711, %528
  %713 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %714 = extractvalue %dx.types.CBufRet.i32 %713, 3
  %715 = add i32 %714, %712
  %716 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %715, i32 0)  ; BufferLoad(srv,index,wot)
  %717 = extractvalue %dx.types.ResRet.i32 %716, 0
  %718 = shl i32 %717, 1
  %719 = or i32 %718, 1
  %720 = add nsw i32 %719, %12
  %721 = and i32 %720, 4095
  %722 = lshr i32 %717, 10
  %723 = or i32 %722, 1
  %724 = add nsw i32 %723, %18
  %725 = and i32 %724, 2047
  %726 = lshr i32 %717, 20
  %727 = or i32 %726, 1
  %728 = add nsw i32 %727, %24
  %729 = and i32 %728, 2047
  %730 = xor i32 %717, -2147483648
  %731 = ashr i32 %730, 31
  %732 = and i32 %731, %540
  %733 = add nsw i32 %725, %732
  %734 = and i32 %731, %544
  %735 = add nsw i32 %729, %734
  %736 = icmp slt i32 %717, 0
  %737 = select i1 %736, float %529, float 0.000000e+00
  %738 = select i1 %736, float %530, float 0.000000e+00
  %739 = select i1 %736, float %531, float 0.000000e+00
  %740 = select i1 %736, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %721, i32 %733, i32 %735, float %737, float %738, float %739, float %740, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %741

; <label>:741                                     ; preds = %706, %703
  %742 = and i1 %666, %704
  br i1 %742, label %743, label %777

; <label>:743                                     ; preds = %741
  %744 = mul nsw i32 %544, 9
  %745 = add nsw i32 %536, 18
  %746 = add i32 %745, %744
  %747 = and i32 %746, 31
  %748 = or i32 %747, %528
  %749 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %750 = extractvalue %dx.types.CBufRet.i32 %749, 3
  %751 = add i32 %750, %748
  %752 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %751, i32 0)  ; BufferLoad(srv,index,wot)
  %753 = extractvalue %dx.types.ResRet.i32 %752, 0
  %754 = shl i32 %753, 1
  %755 = or i32 %754, 1
  %756 = add nsw i32 %755, %12
  %757 = and i32 %756, 4095
  %758 = lshr i32 %753, 10
  %759 = or i32 %758, 1
  %760 = add nsw i32 %759, %18
  %761 = and i32 %760, 2047
  %762 = lshr i32 %753, 20
  %763 = or i32 %762, 1
  %764 = add nsw i32 %763, %24
  %765 = and i32 %764, 2047
  %766 = xor i32 %753, -2147483648
  %767 = ashr i32 %766, 31
  %768 = and i32 %767, %536
  %769 = add nsw i32 %757, %768
  %770 = and i32 %767, %544
  %771 = add nsw i32 %765, %770
  %772 = icmp slt i32 %753, 0
  %773 = select i1 %772, float %529, float 0.000000e+00
  %774 = select i1 %772, float %530, float 0.000000e+00
  %775 = select i1 %772, float %531, float 0.000000e+00
  %776 = select i1 %772, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %769, i32 %761, i32 %771, float %773, float %774, float %775, float %776, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %777

; <label>:777                                     ; preds = %743, %741
  %778 = and i1 %668, %704
  br i1 %778, label %779, label %817

; <label>:779                                     ; preds = %777
  %780 = mul nsw i32 %544, 9
  %781 = mul nsw i32 %540, 3
  %782 = add nsw i32 %536, 18
  %783 = add i32 %782, %781
  %784 = add i32 %783, %780
  %785 = and i32 %784, 31
  %786 = or i32 %785, %528
  %787 = call %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32 59, %dx.types.Handle %7, i32 5)  ; CBufferLoadLegacy(handle,regIndex)
  %788 = extractvalue %dx.types.CBufRet.i32 %787, 3
  %789 = add i32 %788, %786
  %790 = call %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32 68, %dx.types.Handle %4, i32 %789, i32 0)  ; BufferLoad(srv,index,wot)
  %791 = extractvalue %dx.types.ResRet.i32 %790, 0
  %792 = shl i32 %791, 1
  %793 = or i32 %792, 1
  %794 = add nsw i32 %793, %12
  %795 = and i32 %794, 4095
  %796 = lshr i32 %791, 10
  %797 = or i32 %796, 1
  %798 = add nsw i32 %797, %18
  %799 = and i32 %798, 2047
  %800 = lshr i32 %791, 20
  %801 = or i32 %800, 1
  %802 = add nsw i32 %801, %24
  %803 = and i32 %802, 2047
  %804 = xor i32 %791, -2147483648
  %805 = ashr i32 %804, 31
  %806 = and i32 %805, %536
  %807 = add nsw i32 %795, %806
  %808 = and i32 %805, %540
  %809 = add nsw i32 %799, %808
  %810 = and i32 %805, %544
  %811 = add nsw i32 %803, %810
  %812 = icmp slt i32 %791, 0
  %813 = select i1 %812, float %529, float 0.000000e+00
  %814 = select i1 %812, float %530, float 0.000000e+00
  %815 = select i1 %812, float %531, float 0.000000e+00
  %816 = select i1 %812, float %532, float 0.000000e+00
  call void @dx.op.textureStore.f32(i32 67, %dx.types.Handle %1, i32 %807, i32 %809, i32 %811, float %813, float %814, float %815, float %816, i8 15)  ; TextureStore(srv,coord0,coord1,coord2,value0,value1,value2,value3,mask)
  br label %817

; <label>:817                                     ; preds = %779, %777
  ret void
}

; Function Attrs: nounwind readnone
declare i32 @dx.op.threadId.i32(i32, i32) #0

; Function Attrs: nounwind readnone
declare i32 @dx.op.groupId.i32(i32, i32) #0

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.f32 @dx.op.sampleLevel.f32(i32, %dx.types.Handle, %dx.types.Handle, float, float, float, float, i32, i32, i32, float) #1

; Function Attrs: nounwind readnone
declare float @dx.op.unary.f32(i32, float) #0

; Function Attrs: nounwind readnone
declare float @dx.op.binary.f32(i32, float, float) #0

; Function Attrs: nounwind
declare void @dx.op.textureStore.f32(i32, %dx.types.Handle, i32, i32, i32, float, float, float, float, i8) #2

; Function Attrs: nounwind readonly
declare %dx.types.CBufRet.i32 @dx.op.cbufferLoadLegacy.i32(i32, %dx.types.Handle, i32) #1

; Function Attrs: nounwind readonly
declare %dx.types.CBufRet.f32 @dx.op.cbufferLoadLegacy.f32(i32, %dx.types.Handle, i32) #1

; Function Attrs: nounwind readonly
declare %dx.types.Handle @dx.op.createHandle(i32, i8, i32, i32, i1) #1

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.f32 @dx.op.bufferLoad.f32(i32, %dx.types.Handle, i32, i32) #1

; Function Attrs: nounwind readonly
declare %dx.types.ResRet.i32 @dx.op.bufferLoad.i32(i32, %dx.types.Handle, i32, i32) #1

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind readonly }
attributes #2 = { nounwind }

!llvm.ident = !{!0}
!dx.version = !{!1}
!dx.valver = !{!2}
!dx.shaderModel = !{!3}
!dx.resources = !{!4}
!dx.entryPoints = !{!19}

!0 = !{!"clang version 3.7 (tags/RELEASE_370/final)"}
!1 = !{i32 1, i32 0}
!2 = !{i32 1, i32 6}
!3 = !{!"cs", i32 6, i32 0}
!4 = !{!5, !13, !15, !17}
!5 = !{!6, !8, !10, !12}
!6 = !{i32 0, %"class.StructuredBuffer<AdvectionDensityCS_LayerParams>"* undef, !"", i32 0, i32 0, i32 1, i32 12, i32 0, !7}
!7 = !{i32 1, i32 176}
!8 = !{i32 1, %"class.StructuredBuffer<unsigned int>"* undef, !"", i32 0, i32 1, i32 1, i32 12, i32 0, !9}
!9 = !{i32 1, i32 4}
!10 = !{i32 2, %"class.Texture3D<vector<float, 4> >"* undef, !"", i32 0, i32 2, i32 1, i32 4, i32 0, !11}
!11 = !{i32 0, i32 9}
!12 = !{i32 3, %"class.Texture3D<vector<float, 4> >"* undef, !"", i32 0, i32 3, i32 1, i32 4, i32 0, !11}
!13 = !{!14}
!14 = !{i32 0, %"class.RWTexture3D<vector<float, 4> >"* undef, !"", i32 0, i32 0, i32 1, i32 4, i1 false, i1 false, i1 false, !11}
!15 = !{!16}
!16 = !{i32 0, %globalParamsIn* undef, !"", i32 0, i32 0, i32 1, i32 336, null}
!17 = !{!18}
!18 = !{i32 0, %struct.SamplerState* undef, !"", i32 0, i32 0, i32 1, i32 0, null}
!19 = !{void ()* @main, !"main", null, !4, !20}
!20 = !{i32 0, i64 16, i32 4, !21}
!21 = !{i32 128, i32 1, i32 1}

